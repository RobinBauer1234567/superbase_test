[
  {
    "schema": "public",
    "function_name": "assign_random_team",
    "args": "p_league_id bigint, p_user_id uuid",
    "definition": "CREATE OR REPLACE FUNCTION public.assign_random_team(p_league_id bigint, p_user_id uuid)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_num_players int;\r\n    v_target_val numeric;\r\n    v_min_val numeric;\r\n    v_max_val numeric;\r\n    v_player_ids bigint[];\r\n    v_total_val numeric;\r\n    v_season_id int;\r\n    v_retry int := 0;\r\nBEGIN\r\n    SELECT num_starting_players, starting_team_value, season_id\r\n    INTO v_num_players, v_target_val, v_season_id\r\n    FROM leagues WHERE id = p_league_id;\r\n\r\n    IF v_num_players <= 0 THEN RETURN; END IF;\r\n\r\n    v_min_val := GREATEST(0, v_target_val - 1000000);\r\n    v_max_val := v_target_val + 1000000;\r\n\r\n    LOOP\r\n        EXIT WHEN v_retry >= 50;\r\n        v_retry := v_retry + 1;\r\n\r\n        SELECT ARRAY_agg(pid), SUM(mkw)\r\n        INTO v_player_ids, v_total_val\r\n        FROM (\r\n            SELECT s.id as pid, COALESCE(sa.marktwert, 0) as mkw\r\n            FROM public.spieler s\r\n            JOIN public.spieler_analytics sa ON sa.spieler_id = s.id -- HIER NEU\r\n            JOIN public.season_players sp ON sp.player_id = s.id\r\n            WHERE sp.season_id = v_season_id\r\n            AND sa.marktwert > 0 -- HIER NEU\r\n            AND s.id NOT IN (\r\n                SELECT player_id FROM public.league_players WHERE league_id = p_league_id\r\n            )\r\n            ORDER BY random()\r\n            LIMIT v_num_players\r\n        ) sub;\r\n\r\n        IF array_length(v_player_ids, 1) = v_num_players \r\n           AND v_total_val >= v_min_val \r\n           AND v_total_val <= v_max_val THEN\r\n            EXIT;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    IF v_player_ids IS NOT NULL THEN\r\n        INSERT INTO public.league_players (league_id, user_id, player_id, purchase_price)\r\n        SELECT p_league_id, p_user_id, unnest(v_player_ids), 0\r\n        ON CONFLICT (league_id, player_id) DO NOTHING;\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "buy_player_now",
    "args": "p_transfer_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.buy_player_now(p_transfer_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  t_row RECORD;\r\n  buyer_budget BIGINT;\r\n  current_user_id UUID := auth.uid();\r\nBEGIN\r\n  -- 1. Transfer laden\r\n  SELECT * INTO t_row FROM transfer_market WHERE id = p_transfer_id AND is_active = true;\r\n  \r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'Transfer nicht mehr aktiv oder nicht gefunden.';\r\n  END IF;\r\n\r\n  IF t_row.buy_now_price IS NULL THEN\r\n    RAISE EXCEPTION 'Dieser Spieler hat keinen Sofortkauf-Preis.';\r\n  END IF;\r\n\r\n  -- 2. Budget prüfen\r\n  SELECT budget INTO buyer_budget \r\n  FROM league_members \r\n  WHERE user_id = current_user_id AND league_id = t_row.league_id;\r\n\r\n  IF buyer_budget < t_row.buy_now_price THEN\r\n    RAISE EXCEPTION 'Nicht genug Budget.';\r\n  END IF;\r\n\r\n  -- 3. Transaktion ausführen\r\n  -- Käufer zahlt\r\n  UPDATE league_members \r\n  SET budget = budget - t_row.buy_now_price \r\n  WHERE user_id = current_user_id AND league_id = t_row.league_id;\r\n\r\n  -- Verkäufer bekommt Geld (falls User)\r\n  IF t_row.seller_id IS NOT NULL THEN\r\n    UPDATE league_members \r\n    SET budget = budget + t_row.buy_now_price \r\n    WHERE user_id = t_row.seller_id AND league_id = t_row.league_id;\r\n  END IF;\r\n\r\n  -- Spieler übertragen\r\n  IF t_row.seller_id IS NOT NULL THEN\r\n    UPDATE league_players\r\n    SET user_id = current_user_id, formation_index = 99\r\n    WHERE player_id = t_row.player_id AND league_id = t_row.league_id;\r\n  ELSE\r\n    INSERT INTO league_players (league_id, user_id, player_id, formation_index)\r\n    VALUES (t_row.league_id, current_user_id, t_row.player_id, 99);\r\n  END IF;\r\n\r\n  -- Transfer schließen\r\n  UPDATE transfer_market SET is_active = false WHERE id = t_row.id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "calculate_fantasy_points",
    "args": "p_pos text, p_stats jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.calculate_fantasy_points(p_pos text, p_stats jsonb)\n RETURNS integer\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    v_score numeric := 0;\r\n    -- Hilfsfunktion um sicher Zahlen aus dem JSON zu holen\r\n    val numeric;\r\nBEGIN\r\n    -- Wir nutzen eine lokale Funktion für den sauberen Zugriff (gibt 0 zurück wenn Key fehlt)\r\n    -- Da SQL keine Nested Functions hat, machen wir es inline mit COALESCE\r\n    \r\n    -- *** TORWART (G) ***\r\n    IF p_pos = 'TW' OR p_pos = 'G' THEN\r\n        v_score := v_score + 0.002 * COALESCE((p_stats->>'totalPass')::numeric, 0);\r\n        v_score := v_score + 0.015 * COALESCE((p_stats->>'accuratePass')::numeric, 0);\r\n        v_score := v_score + 0.003 * COALESCE((p_stats->>'totalLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.03  * COALESCE((p_stats->>'accurateLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.5   * COALESCE((p_stats->>'goalAssist')::numeric, 0);\r\n        v_score := v_score + 0.08  * COALESCE((p_stats->>'aerialWon')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'aerialLost')::numeric, 0);\r\n        v_score := v_score + 0.02  * COALESCE((p_stats->>'duelWon')::numeric, 0);\r\n        v_score := v_score - 0.02  * COALESCE((p_stats->>'duelLost')::numeric, 0);\r\n        v_score := v_score - 0.02  * COALESCE((p_stats->>'challengeLost')::numeric, 0);\r\n        v_score := v_score + 0.01  * COALESCE((p_stats->>'totalContest')::numeric, 0);\r\n        v_score := v_score + 0.02  * COALESCE((p_stats->>'wonContest')::numeric, 0);\r\n        v_score := v_score + 0.1   * COALESCE((p_stats->>'interceptionWon')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'totalClearance')::numeric, 0);\r\n        v_score := v_score - 0.3   * COALESCE((p_stats->>'errorLeadToAShot')::numeric, 0);\r\n        v_score := v_score - 0.75  * COALESCE((p_stats->>'errorLeadToAGoal')::numeric, 0);\r\n        v_score := v_score + 0.02  * COALESCE((p_stats->>'wasFouled')::numeric, 0);\r\n        v_score := v_score + 0.2   * COALESCE((p_stats->>'goodHighClaim')::numeric, 0);\r\n        v_score := v_score + 0.15  * COALESCE((p_stats->>'totalKeeperSweeper')::numeric, 0);\r\n        v_score := v_score + 0.25  * COALESCE((p_stats->>'accurateKeeperSweeper')::numeric, 0);\r\n        v_score := v_score + 2.0   * COALESCE((p_stats->>'expectedAssists')::numeric, 0);\r\n        v_score := v_score + 0.02  * COALESCE((p_stats->>'totalTackle')::numeric, 0);\r\n        v_score := v_score + 0.4   * COALESCE((p_stats->>'lastManTackle')::numeric, 0);\r\n        v_score := v_score + 0.15  * COALESCE((p_stats->>'bigChanceCreated')::numeric, 0);\r\n        v_score := v_score + 0.75  * COALESCE((p_stats->>'penaltySave')::numeric, 0);\r\n        v_score := v_score - 0.5   * COALESCE((p_stats->>'penaltyConceded')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'fouls')::numeric, 0);\r\n        v_score := v_score + 0.15  * COALESCE((p_stats->>'keyPass')::numeric, 0);\r\n        v_score := v_score + 0.15  * COALESCE((p_stats->>'punches')::numeric, 0);\r\n        v_score := v_score + 0.001 * COALESCE((p_stats->>'touches')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'possessionLostCtrl')::numeric, 0);\r\n        v_score := v_score + 0.2   * COALESCE((p_stats->>'saves')::numeric, 0);\r\n        v_score := v_score - 0.15  * COALESCE((p_stats->>'goalsConceded')::numeric, 0);\r\n        v_score := v_score + 1.0   * COALESCE((p_stats->>'cleanSheet')::numeric, 0);\r\n        v_score := v_score + 0.02  * COALESCE((p_stats->>'shotsFaced')::numeric, 0);\r\n        \r\n        RETURN ROUND(v_score * 50);\r\n    END IF;\r\n\r\n    -- *** ABWEHR (D) ***\r\n    IF p_pos = 'D' OR p_pos LIKE '%V' THEN -- Fängt IV, RV, LV etc. ab\r\n        v_score := v_score + 0.005 * COALESCE((p_stats->>'totalPass')::numeric, 0);\r\n        v_score := v_score + 0.005 * COALESCE((p_stats->>'accuratePass')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'totalLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'accurateLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.5   * COALESCE((p_stats->>'goalAssist')::numeric, 0);\r\n        v_score := v_score + 1.0   * COALESCE((p_stats->>'goals')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'totalCross')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'accurateCross')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'aerialLost')::numeric, 0);\r\n        v_score := v_score + 0.1   * COALESCE((p_stats->>'aerialWon')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'duelLost')::numeric, 0);\r\n        v_score := v_score + 0.1   * COALESCE((p_stats->>'duelWon')::numeric, 0);\r\n        v_score := v_score - 0.1   * COALESCE((p_stats->>'dispossessed')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'shotOffTarget')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'totalClearance')::numeric, 0);\r\n        v_score := v_score - 0.1   * COALESCE((p_stats->>'clearanceOffLine')::numeric, 0);\r\n        v_score := v_score - 0.1   * COALESCE((p_stats->>'fouls')::numeric, 0);\r\n        v_score := v_score + 0.01  * COALESCE((p_stats->>'touches')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'possessionLostCtrl')::numeric, 0);\r\n        v_score := v_score + 1.0   * COALESCE((p_stats->>'expectedAssists')::numeric, 0);\r\n        v_score := v_score + 0.2   * COALESCE((p_stats->>'keyPass')::numeric, 0);\r\n        v_score := v_score + 0.1   * COALESCE((p_stats->>'totalTackle')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'wonContest')::numeric, 0);\r\n        v_score := v_score - 0.05  * COALESCE((p_stats->>'challengeLost')::numeric, 0);\r\n        v_score := v_score + 0.05  * COALESCE((p_stats->>'outfielderBlock')::numeric, 0);\r\n        v_score := v_score + 0.1   * COALESCE((p_stats->>'interceptionWon')::numeric, 0);\r\n        v_score := v_score + 0.2   * COALESCE((p_stats->>'lastManTackle')::numeric, 0);\r\n        v_score := v_score + 0.2   * COALESCE((p_stats->>'bigChanceCreated')::numeric, 0);\r\n        v_score := v_score - 0.2   * COALESCE((p_stats->>'bigChanceMissed')::numeric, 0);\r\n        v_score := v_score - 0.2   * COALESCE((p_stats->>'errorLeadToAShot')::numeric, 0);\r\n        v_score := v_score - 0.3   * COALESCE((p_stats->>'errorLeadToAGoal')::numeric, 0);\r\n    END IF;\r\n\r\n    -- *** MITTELFELD (M) ***\r\n    IF p_pos = 'M' OR p_pos LIKE '%M' THEN \r\n        v_score := v_score + 0.008 * COALESCE((p_stats->>'totalPass')::numeric, 0);\r\n        v_score := v_score + 0.017 * COALESCE((p_stats->>'accuratePass')::numeric, 0);\r\n        v_score := v_score + 0.020 * COALESCE((p_stats->>'touches')::numeric, 0);\r\n        v_score := v_score + 0.025 * COALESCE((p_stats->>'totalLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.025 * COALESCE((p_stats->>'accurateLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.060 * COALESCE((p_stats->>'totalCross')::numeric, 0);\r\n        v_score := v_score + 0.120 * COALESCE((p_stats->>'accurateCross')::numeric, 0);\r\n        v_score := v_score + 0.400 * COALESCE((p_stats->>'goalAssist')::numeric, 0);\r\n        v_score := v_score + 0.350 * COALESCE((p_stats->>'keyPass')::numeric, 0);\r\n        v_score := v_score + 0.200 * COALESCE((p_stats->>'onTargetScoringAttempt')::numeric, 0);\r\n        v_score := v_score + 0.600 * COALESCE((p_stats->>'goals')::numeric, 0);\r\n        v_score := v_score + 1.800 * COALESCE((p_stats->>'expectedAssists')::numeric, 0);\r\n        v_score := v_score - 0.040 * COALESCE((p_stats->>'aerialLost')::numeric, 0);\r\n        v_score := v_score + 0.060 * COALESCE((p_stats->>'aerialWon')::numeric, 0);\r\n        v_score := v_score - 0.040 * COALESCE((p_stats->>'duelLost')::numeric, 0);\r\n        v_score := v_score + 0.060 * COALESCE((p_stats->>'duelWon')::numeric, 0);\r\n        v_score := v_score + 0.040 * COALESCE((p_stats->>'totalContest')::numeric, 0);\r\n        v_score := v_score + 0.040 * COALESCE((p_stats->>'wonContest')::numeric, 0);\r\n        v_score := v_score + 0.120 * COALESCE((p_stats->>'blockedScoringAttempt')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'outfielderBlock')::numeric, 0);\r\n        v_score := v_score + 0.080 * COALESCE((p_stats->>'totalClearance')::numeric, 0);\r\n        v_score := v_score + 0.120 * COALESCE((p_stats->>'interceptionWon')::numeric, 0);\r\n        v_score := v_score + 0.120 * COALESCE((p_stats->>'totalTackle')::numeric, 0);\r\n        v_score := v_score - 0.080 * COALESCE((p_stats->>'challengeLost')::numeric, 0);\r\n        v_score := v_score - 0.040 * COALESCE((p_stats->>'fouls')::numeric, 0);\r\n        v_score := v_score - 0.080 * COALESCE((p_stats->>'dispossessed')::numeric, 0);\r\n        v_score := v_score - 0.040 * COALESCE((p_stats->>'totalOffside')::numeric, 0);\r\n        v_score := v_score - 0.040 * COALESCE((p_stats->>'shotOffTarget')::numeric, 0);\r\n        v_score := v_score - 0.200 * COALESCE((p_stats->>'errorLeadToAGoal')::numeric, 0);\r\n        v_score := v_score - 0.150 * COALESCE((p_stats->>'errorLeadToAShot')::numeric, 0);\r\n        v_score := v_score + 0.350 * COALESCE((p_stats->>'bigChanceCreated')::numeric, 0);\r\n        v_score := v_score - 0.250 * COALESCE((p_stats->>'bigChanceMissed')::numeric, 0);\r\n        v_score := v_score - 0.030 * COALESCE((p_stats->>'possessionLostCtrl')::numeric, 0);\r\n        v_score := v_score + 0.300 * COALESCE((p_stats->>'penaltyWon')::numeric, 0);\r\n        v_score := v_score + 0.080 * COALESCE((p_stats->>'clearanceOffLine')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'hitWoodwork')::numeric, 0);\r\n    END IF;\r\n\r\n    -- *** STURM (F) ***\r\n    IF p_pos = 'F' OR p_pos = 'ST' OR p_pos LIKE '%A' THEN \r\n        v_score := v_score + 0.005 * COALESCE((p_stats->>'totalPass')::numeric, 0);\r\n        v_score := v_score + 0.010 * COALESCE((p_stats->>'accuratePass')::numeric, 0);\r\n        v_score := v_score + 0.005 * COALESCE((p_stats->>'totalLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.015 * COALESCE((p_stats->>'accurateLongBalls')::numeric, 0);\r\n        v_score := v_score + 0.200 * COALESCE((p_stats->>'keyPass')::numeric, 0);\r\n        v_score := v_score + 0.500 * COALESCE((p_stats->>'goalAssist')::numeric, 0);\r\n        v_score := v_score + 1.000 * COALESCE((p_stats->>'expectedAssists')::numeric, 0);\r\n        v_score := v_score + 1.000 * COALESCE((p_stats->>'expectedGoals')::numeric, 0);\r\n        v_score := v_score - 0.050 * COALESCE((p_stats->>'totalCross')::numeric, 0);\r\n        v_score := v_score + 0.200 * COALESCE((p_stats->>'accurateCross')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'aerialWon')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'aerialLost')::numeric, 0);\r\n        v_score := v_score + 0.050 * COALESCE((p_stats->>'duelWon')::numeric, 0);\r\n        v_score := v_score - 0.050 * COALESCE((p_stats->>'duelLost')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'challengeLost')::numeric, 0);\r\n        v_score := v_score - 0.150 * COALESCE((p_stats->>'dispossessed')::numeric, 0);\r\n        v_score := v_score + 0.020 * COALESCE((p_stats->>'totalContest')::numeric, 0);\r\n        v_score := v_score + 0.030 * COALESCE((p_stats->>'wonContest')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'shotOffTarget')::numeric, 0);\r\n        v_score := v_score + 0.200 * COALESCE((p_stats->>'onTargetScoringAttempt')::numeric, 0);\r\n        v_score := v_score - 0.050 * COALESCE((p_stats->>'blockedScoringAttempt')::numeric, 0);\r\n        v_score := v_score + 0.300 * COALESCE((p_stats->>'bigChanceCreated')::numeric, 0);\r\n        v_score := v_score - 0.300 * COALESCE((p_stats->>'bigChanceMissed')::numeric, 0);\r\n        v_score := v_score - 0.500 * COALESCE((p_stats->>'errorLeadToAGoal')::numeric, 0);\r\n        v_score := v_score - 0.200 * COALESCE((p_stats->>'errorLeadToAShot')::numeric, 0);\r\n        v_score := v_score + 0.200 * COALESCE((p_stats->>'hitWoodwork')::numeric, 0);\r\n        v_score := v_score + 0.500 * COALESCE((p_stats->>'penaltyWon')::numeric, 0);\r\n        v_score := v_score - 0.300 * COALESCE((p_stats->>'penaltyMiss')::numeric, 0);\r\n        v_score := v_score + 0.030 * COALESCE((p_stats->>'totalClearance')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'clearanceOffLine')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'interceptionWon')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'totalTackle')::numeric, 0);\r\n        v_score := v_score + 0.100 * COALESCE((p_stats->>'outfielderBlock')::numeric, 0);\r\n        v_score := v_score + 0.005 * COALESCE((p_stats->>'touches')::numeric, 0);\r\n        v_score := v_score - 0.050 * COALESCE((p_stats->>'possessionLostCtrl')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'fouls')::numeric, 0);\r\n        v_score := v_score - 0.100 * COALESCE((p_stats->>'totalOffside')::numeric, 0);\r\n    END IF;\r\n\r\n    -- Falls Position D/M/F, dann * 100\r\n    IF p_pos <> 'TW' AND p_pos <> 'G' THEN\r\n        RETURN ROUND(v_score * 100);\r\n    END IF;\r\n\r\n    RETURN 0;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "calculate_formation_array",
    "args": "p_formation text",
    "definition": "CREATE OR REPLACE FUNCTION public.calculate_formation_array(p_formation text)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    v_result text[] := '{}';\r\n    i int;\r\nBEGIN\r\n    -- Array wie gewohnt aufbauen (Index 0 bis 10)\r\n    FOR i IN 0..10 LOOP\r\n        v_result := array_append(v_result, public.get_position_from_formation(p_formation, i));\r\n    END LOOP;\r\n    \r\n    -- WICHTIG: Das Text-Array mit to_jsonb() in ein JSON-Objekt umwandeln\r\n    RETURN to_jsonb(v_result); \r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_schedule_update_needed",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.check_schedule_update_needed(p_season_id bigint)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_last timestamp with time zone;\r\nBEGIN\r\n    SELECT last_schedule_update INTO v_last FROM public.season WHERE id = p_season_id;\r\n    -- Wenn das Datum null ist oder älter als 2 Tage\r\n    IF v_last IS NULL OR v_last < (now() - interval '2 days') THEN\r\n        RETURN true;\r\n    END IF;\r\n    RETURN false;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "cleanup_duplicate_matches",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.cleanup_duplicate_matches(p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- Wir löschen jedes Spiel (s1)...\r\n    DELETE FROM public.spiel s1\r\n    WHERE s1.season_id = p_season_id\r\n      -- ... wenn es ein anderes Spiel (s2) in derselben Saison gibt, \r\n      -- das die gleichen Teams hat, aber eine HÖHERE ID besitzt!\r\n      AND EXISTS (\r\n          SELECT 1 FROM public.spiel s2\r\n          WHERE s2.season_id = s1.season_id\r\n            AND s2.heimteam_id = s1.heimteam_id\r\n            AND s2.auswärtsteam_id = s1.auswärtsteam_id\r\n            AND s2.id > s1.id \r\n      );\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_league_and_add_admin",
    "args": "league_name text, start_budget numeric, s_id bigint, is_league_public boolean, squad_limit integer, num_starting_players integer, starting_team_value numeric",
    "definition": "CREATE OR REPLACE FUNCTION public.create_league_and_add_admin(league_name text, start_budget numeric, s_id bigint, is_league_public boolean, squad_limit integer, num_starting_players integer, starting_team_value numeric)\n RETURNS bigint\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  new_league_id bigint;\r\nBEGIN\r\n  -- 1. Liga anlegen\r\n  INSERT INTO leagues (name, starting_budget, season_id, admin_id, is_public, squad_limit, num_starting_players, starting_team_value)\r\n  VALUES (league_name, start_budget, s_id, auth.uid(), is_league_public, squad_limit, num_starting_players, starting_team_value)\r\n  RETURNING id INTO new_league_id;\r\n\r\n  -- 2. Admin als Member hinzufügen\r\n  INSERT INTO league_members (league_id, user_id, budget, manager_team_name)\r\n  VALUES (new_league_id, auth.uid(), start_budget, 'Admin Team');\r\n\r\n  -- 3. Admin bekommt sein Team zugelost\r\n  PERFORM public.assign_random_team(new_league_id, auth.uid());\r\n\r\n  -- NEU 4. Transfermarkt füllen! Wir werfen direkt 15 Spieler auf den Markt\r\n  PERFORM public.generate_daily_transfers(new_league_id, s_id, 15);\r\n\r\n  RETURN new_league_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "daily_marktwert_update",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.daily_marktwert_update()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_current_season bigint;\r\n    v_settings RECORD;\r\nBEGIN\r\n    -- 1. Einstellungen laden\r\n    SELECT * INTO v_settings FROM public.game_settings WHERE id = 1;\r\n\r\n    -- Fallback-Sicherung\r\n    IF v_settings IS NULL THEN\r\n        RAISE EXCEPTION 'Fehler: game_settings (id=1) wurde nicht gefunden. Update abgebrochen!';\r\n    END IF;\r\n\r\n    -- 2. Aktuelle Saison ermitteln (Wir nehmen die mit der höchsten ID)\r\n    SELECT id INTO v_current_season \r\n    FROM public.season \r\n    ORDER BY id DESC \r\n    LIMIT 1;\r\n    \r\n    IF v_current_season IS NULL THEN\r\n        RAISE NOTICE 'Keine aktive Saison gefunden. Abbruch.';\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- 3. Vorhersage-Parameter auf den neuesten Stand bringen\r\n    PERFORM public.update_all_matchup_faktors(v_current_season);\r\n    PERFORM public.update_all_spieler_analytics(v_current_season);\r\n\r\n    -- 4. Die eigentliche Börsen-Anpassung für alle Spieler mit dynamischen Werten\r\n    UPDATE public.spieler_analytics\r\n    SET \r\n        -- Zielwert berechnen (Calculated Marktwert) mit den globalen Settings\r\n        calculated_marktwert = ROUND(v_settings.mw_multiplier * power(COALESCE(expected_points, 0), v_settings.mw_exponent) + v_settings.mw_base_value),\r\n        \r\n        -- Echten Marktwert annähern (mit dynamischem Prozentsatz)\r\n        marktwert = ROUND(\r\n            marktwert + (\r\n                (v_settings.mw_multiplier * power(COALESCE(expected_points, 0), v_settings.mw_exponent) + v_settings.mw_base_value) - marktwert\r\n            ) * v_settings.mw_daily_adjustment\r\n        ),\r\n        \r\n        last_updated_at = now();\r\n\r\n    RAISE NOTICE 'Tägliches Marktwert-Update mit dynamischen Settings erfolgreich abgeschlossen!';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "deactivate_idle_leagues",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.deactivate_idle_leagues()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Setze is_active auf false...\r\n  UPDATE public.leagues\r\n  SET is_active = false\r\n  -- ...aber nur bei Ligen, die noch aktiv sind UND deren letztes Update älter als 14 Tage ist\r\n  WHERE is_active = true\r\n    AND last_activity_at < (now() - interval '14 days');\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "generate_daily_transfers",
    "args": "p_league_id bigint, p_season_id bigint, p_amount integer",
    "definition": "CREATE OR REPLACE FUNCTION public.generate_daily_transfers(p_league_id bigint, p_season_id bigint, p_amount integer)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  player_rec RECORD;\r\n  v_random_hours numeric;\r\nBEGIN\r\n  FOR player_rec IN\r\n    SELECT s.id, sa.marktwert \r\n    FROM public.spieler s\r\n    JOIN public.spieler_analytics sa ON sa.spieler_id = s.id -- HIER NEU\r\n    WHERE \r\n    EXISTS (SELECT 1 FROM public.season_players sp WHERE sp.player_id = s.id AND sp.season_id = p_season_id)\r\n    AND NOT EXISTS (SELECT 1 FROM public.league_players lp WHERE lp.player_id = s.id AND lp.league_id = p_league_id)\r\n    AND NOT EXISTS (SELECT 1 FROM public.transfer_market tm WHERE tm.player_id = s.id AND tm.league_id = p_league_id AND tm.is_active = true)\r\n    AND sa.marktwert IS NOT NULL AND sa.marktwert > 0 -- HIER NEU\r\n    ORDER BY random()\r\n    LIMIT p_amount\r\n  LOOP\r\n    v_random_hours := 24 + (random() * 48);\r\n\r\n    INSERT INTO public.transfer_market (\r\n      league_id, player_id, seller_id, listed_at, expires_at, min_bid_price, buy_now_price, is_active\r\n    )\r\n    VALUES (\r\n      p_league_id, player_rec.id, NULL, now(), now() + (v_random_hours * interval '1 hour'), \r\n      player_rec.marktwert, player_rec.marktwert + 3000000, true\r\n    );\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_league_ranking",
    "args": "p_league_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.get_league_ranking(p_league_id bigint)\n RETURNS TABLE(user_id uuid, username text, manager_team_name text, total_points bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT\r\n        p.user_id,\r\n        p.username,\r\n        lm.manager_team_name,\r\n        COALESCE(SUM(mp.points), 0)::BIGINT AS total_points\r\n    FROM\r\n        public.league_members lm\r\n    JOIN\r\n        public.profiles p ON lm.user_id = p.user_id\r\n    LEFT JOIN\r\n        public.matchday_points mp ON lm.user_id = mp.user_id AND lm.league_id = mp.league_id\r\n    WHERE\r\n        lm.league_id = p_league_id\r\n    GROUP BY\r\n        p.user_id, p.username, lm.manager_team_name\r\n    ORDER BY\r\n        total_points DESC;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_pending_updates",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.get_pending_updates(p_season_id bigint)\n RETURNS TABLE(id bigint, heimteam_id bigint, \"auswärtsteam_id\" bigint)\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    RETURN QUERY\r\n    SELECT s.id::bigint, s.heimteam_id::bigint, s.auswärtsteam_id::bigint\r\n    FROM spiel s\r\n    WHERE s.season_id = p_season_id\r\n      AND s.status <> 'final' -- Nur Spiele, die noch nicht final sind\r\n      AND (\r\n          -- Fall A: LIVE-SPIELE (Hohe Priorität)\r\n          -- Spiel läuft und Update ist älter als 5 Minuten\r\n          (s.status = 'läuft' AND s.last_updated_at < (now() - interval '5 minutes'))\r\n          \r\n          OR\r\n          \r\n          -- Fall B: ÜBERFÄLLIGE ANPFIFFE (Der Fix für dein Problem!)\r\n          -- Status ist 'nicht gestartet', aber Anpfiff war schon.\r\n          -- Wir prüfen das, wenn das letzte Update länger als 60 Minuten her ist.\r\n          -- Das fängt auch Spiele von gestern oder letzter Woche ab.\r\n          (s.status = 'nicht gestartet' AND s.datum <= now() AND s.last_updated_at < (now() - interval '60 minutes'))\r\n          \r\n          OR\r\n          \r\n          -- Fall C: NACHKONTROLLE\r\n          -- Spiel ist 'beendet', aber noch nicht 'final'. Wir prüfen alle 30 Min.\r\n          (s.status = 'beendet' AND s.last_updated_at < (now() - interval '30 minutes'))\r\n          \r\n          OR \r\n          \r\n          -- Fall D: SICHERHEITSNETZ (Besenwagen)\r\n          -- Irgendein Spiel (außer 'final'), das seit über 12 Stunden nicht angefasst wurde.\r\n          -- Das korrigiert alles, was durch andere Raster fällt.\r\n          (s.last_updated_at < (now() - interval '12 hours'))\r\n      )\r\n    ORDER BY s.datum ASC -- Älteste Spiele zuerst fixen!\r\n    LIMIT 5;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_position_from_formation",
    "args": "p_formation text, p_index integer",
    "definition": "CREATE OR REPLACE FUNCTION public.get_position_from_formation(p_formation text, p_index integer)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\r\nDECLARE\r\n    parts int[];\r\n    defenders int;\r\n    attackers int;\r\n    midfielders int[];\r\n    mf_length int;\r\n    midfield_sum int := 0;\r\n    \r\n    defense_end_index int;\r\n    midfield_end_index int;\r\n    attacker_end_index int;\r\n    \r\n    pos_index int;\r\n    i int;\r\nBEGIN\r\n    -- 1. Torwart und Ersatzspieler\r\n    IF p_index = 0 THEN RETURN 'TW'; END IF;\r\n    IF p_index > 10 THEN RETURN 'SUB'; END IF;\r\n    IF p_formation = 'N/A' OR p_formation IS NULL THEN RETURN 'N/A'; END IF;\r\n\r\n    -- 2. Formation parsen (z.B. \"4-2-3-1\" -> {4,2,3,1})\r\n    BEGIN\r\n        parts := string_to_array(p_formation, '-')::int[];\r\n    EXCEPTION WHEN OTHERS THEN\r\n        RETURN 'N/A';\r\n    END;\r\n    \r\n    IF array_length(parts, 1) < 2 OR parts IS NULL THEN\r\n        RETURN 'N/A';\r\n    END IF;\r\n    \r\n    -- Struktur aufbauen\r\n    defenders := parts[1];\r\n    attackers := parts[array_length(parts, 1)];\r\n    \r\n    -- Mittelfeld extrahieren (alles zwischen Abwehr und Sturm)\r\n    mf_length := array_length(parts, 1) - 2;\r\n    midfielders := ARRAY[]::int[];\r\n    \r\n    IF mf_length > 0 THEN\r\n        FOR i IN 2 .. (array_length(parts, 1) - 1) LOOP\r\n            midfielders := array_append(midfielders, parts[i]);\r\n            midfield_sum := midfield_sum + parts[i];\r\n        END LOOP;\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 3. ABWEHR\r\n    -- ==========================================\r\n    defense_end_index := defenders;\r\n    IF p_index > 0 AND p_index <= defense_end_index THEN\r\n        pos_index := p_index;\r\n        IF defenders = 3 THEN RETURN 'IV'; END IF;\r\n        IF defenders = 4 THEN\r\n            IF pos_index = 1 THEN RETURN 'RV'; END IF;\r\n            IF pos_index = 4 THEN RETURN 'LV'; END IF;\r\n            RETURN 'IV';\r\n        END IF;\r\n        IF defenders = 5 THEN\r\n            IF pos_index = 1 THEN RETURN 'RV'; END IF;\r\n            IF pos_index = 5 THEN RETURN 'LV'; END IF;\r\n            RETURN 'IV';\r\n        END IF;\r\n        RETURN 'IV'; -- Fallback für andere Abwehrreihen\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 4. MITTELFELD\r\n    -- ==========================================\r\n    midfield_end_index := defense_end_index + midfield_sum;\r\n    IF p_index > defense_end_index AND p_index <= midfield_end_index THEN\r\n        pos_index := p_index - defense_end_index;\r\n        \r\n        -- Fall A: Nur eine Mittelfeld-Reihe (z.B. 4-4-2)\r\n        IF mf_length = 1 THEN\r\n            IF midfielders[1] > 3 THEN\r\n                IF pos_index = 1 THEN RETURN 'RA'; END IF;\r\n                IF pos_index = midfielders[1] THEN RETURN 'LA'; END IF;\r\n            END IF;\r\n            RETURN 'ZM';\r\n        END IF;\r\n\r\n        -- Fall B: Erste Mittelfeld-Reihe (z.B. die 2 im 4-2-3-1)\r\n        IF pos_index <= midfielders[1] THEN\r\n            IF midfielders[1] >= 3 THEN\r\n                IF pos_index = 1 THEN RETURN 'RV'; END IF;\r\n                IF pos_index = midfielders[1] THEN RETURN 'LV'; END IF;\r\n            END IF;\r\n            IF midfielders[1] = 3 THEN RETURN 'ZM'; END IF;\r\n            RETURN 'ZDM';\r\n        END IF;\r\n\r\n        -- Fall C: Zweite Mittelfeld-Reihe (z.B. die 3 im 4-2-3-1)\r\n        IF mf_length >= 2 THEN\r\n            IF pos_index <= (midfielders[1] + midfielders[2]) THEN\r\n                IF midfielders[2] >= 3 THEN\r\n                    IF pos_index = (midfielders[1] + 1) THEN RETURN 'RA'; END IF;\r\n                    IF pos_index = (midfielders[1] + midfielders[2]) THEN RETURN 'LA'; END IF;\r\n                    IF midfielders[2] = 3 THEN RETURN 'ZOM'; END IF;\r\n                    RETURN 'ZM';\r\n                END IF;\r\n                IF mf_length >= 3 THEN RETURN 'ZM'; END IF;\r\n                RETURN 'ZOM';\r\n            END IF;\r\n        END IF;\r\n\r\n        -- Fall D: Dritte Mittelfeld-Reihe (z.B. extrem tiefe Formationen)\r\n        IF mf_length >= 3 THEN\r\n            IF pos_index <= (midfielders[1] + midfielders[2] + midfielders[3]) THEN\r\n                RETURN 'ZOM';\r\n            END IF;\r\n        END IF;\r\n\r\n        RETURN 'M'; -- Fallback für komplexes Mittelfeld\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 5. STURM\r\n    -- ==========================================\r\n    attacker_end_index := midfield_end_index + attackers;\r\n    IF p_index > midfield_end_index AND p_index <= attacker_end_index THEN\r\n        pos_index := p_index - midfield_end_index;\r\n        IF attackers <= 2 THEN RETURN 'ST'; END IF;\r\n        IF attackers = 3 THEN\r\n            IF pos_index = 1 THEN RETURN 'RA'; END IF;\r\n            IF pos_index = 3 THEN RETURN 'LA'; END IF;\r\n            RETURN 'ST';\r\n        END IF;\r\n    END IF;\r\n\r\n    -- 6. FALLBACK\r\n    RETURN 'SUB';\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_member_activity",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_member_activity()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_user_name text;\r\nBEGIN\r\n    -- Namen holen\r\n    SELECT username INTO v_user_name FROM profiles WHERE user_id = COALESCE(NEW.user_id, OLD.user_id);\r\n    \r\n    IF (TG_OP = 'INSERT') THEN\r\n        INSERT INTO league_activities (league_id, type, content)\r\n        VALUES (NEW.league_id, 'JOIN', jsonb_build_object('user_name', v_user_name));\r\n        RETURN NEW;\r\n    ELSIF (TG_OP = 'DELETE') THEN\r\n        INSERT INTO league_activities (league_id, type, content)\r\n        VALUES (OLD.league_id, 'LEAVE', jsonb_build_object('user_name', v_user_name));\r\n        RETURN OLD;\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_new_listing",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_listing()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_player_name text;\r\n    v_seller_name text;\r\nBEGIN\r\n    -- Spielername holen\r\n    SELECT name INTO v_player_name FROM spieler WHERE id = NEW.player_id;\r\n    -- Verkäufername holen\r\n    SELECT username INTO v_seller_name FROM profiles WHERE user_id = NEW.seller_id;\r\n\r\n    INSERT INTO league_activities (league_id, type, content)\r\n    VALUES (\r\n        NEW.league_id, \r\n        'LISTING', \r\n        jsonb_build_object(\r\n            'player_name', v_player_name, \r\n            'seller_name', v_seller_name,\r\n            'price', COALESCE(NEW.buy_now_price, NEW.min_bid_price)\r\n        )\r\n    );\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_player_transfer",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_player_transfer()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_player_name text;\r\n    v_buyer_name text;\r\n    v_seller_name text;\r\nBEGIN\r\n    -- Wir reagieren nur, wenn sich der user_id ändert (Besitzerwechsel)\r\n    IF (OLD.user_id IS DISTINCT FROM NEW.user_id AND NEW.user_id IS NOT NULL) THEN\r\n        \r\n        -- Daten sammeln\r\n        SELECT name INTO v_player_name FROM spieler WHERE id = NEW.player_id;\r\n        SELECT username INTO v_buyer_name FROM profiles WHERE user_id = NEW.user_id;\r\n        \r\n        IF (OLD.user_id IS NOT NULL) THEN\r\n            SELECT username INTO v_seller_name FROM profiles WHERE user_id = OLD.user_id;\r\n        ELSE\r\n            v_seller_name := 'System'; -- oder Pack Opening\r\n        END IF;\r\n\r\n        INSERT INTO league_activities (league_id, type, content)\r\n        VALUES (\r\n            NEW.league_id, \r\n            'TRANSFER', \r\n            jsonb_build_object(\r\n                'player_name', v_player_name, \r\n                'buyer_name', v_buyer_name,\r\n                'seller_name', v_seller_name,\r\n                'price', NEW.purchase_price\r\n            )\r\n        );\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "init_player_from_sofascore",
    "args": "p_player_id bigint, p_formation text, p_lineup_index integer, p_api_position text, p_ratings numeric[]",
    "definition": "CREATE OR REPLACE FUNCTION public.init_player_from_sofascore(p_player_id bigint, p_formation text, p_lineup_index integer, p_api_position text, p_ratings numeric[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_final_position text;\r\n    v_avg_points numeric := 0;\r\n    v_calc_mw bigint;\r\n    v_rating numeric;\r\n    v_points_sum numeric := 0;\r\n    v_points_count int := 0;\r\n    \r\n    -- NEU: Variable für die Einstellungen\r\n    v_settings RECORD;\r\nBEGIN\r\n    -- NEU: Einstellungen laden\r\n    SELECT * INTO v_settings FROM public.game_settings WHERE id = 1;\r\n    \r\n    -- Fallback, falls die Einstellungen (warum auch immer) fehlen\r\n    IF v_settings IS NULL THEN\r\n        v_calc_mw := 1000000; \r\n    ELSE\r\n        v_calc_mw := v_settings.mw_base_value;\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 1. POSITION ERMITTELN\r\n    -- ==========================================\r\n    IF p_formation IS NOT NULL AND p_lineup_index IS NOT NULL AND p_lineup_index <= 10 THEN\r\n        v_final_position := public.get_position_from_formation(p_formation, p_lineup_index);\r\n    END IF;\r\n\r\n    IF v_final_position IS NULL OR v_final_position IN ('N/A', 'SUB', 'N/V') THEN\r\n        v_final_position := CASE \r\n            WHEN p_api_position = 'G' THEN 'TW'\r\n            WHEN p_api_position = 'D' THEN 'IV'\r\n            WHEN p_api_position = 'M' THEN 'ZM'\r\n            WHEN p_api_position = 'F' THEN 'ST'\r\n            ELSE 'SUB'\r\n        END;\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 2. MARKTWERT BERECHNEN (Mit Variablen!)\r\n    -- ==========================================\r\n    IF array_length(p_ratings, 1) > 0 THEN\r\n        FOREACH v_rating IN ARRAY p_ratings\r\n        LOOP\r\n            IF v_rating IS NOT NULL THEN\r\n                v_points_sum := v_points_sum + ROUND((v_rating - 6.0) * 100);\r\n                v_points_count := v_points_count + 1;\r\n            END IF;\r\n        END LOOP;\r\n\r\n        IF v_points_count > 0 THEN\r\n            v_avg_points := v_points_sum / v_points_count;\r\n            \r\n            IF v_avg_points > 0 AND v_settings IS NOT NULL THEN\r\n                -- NEU: Die Formel greift komplett auf die Einstellungen zu!\r\n                v_calc_mw := ROUND(v_settings.mw_multiplier * power(v_avg_points, v_settings.mw_exponent) + v_settings.mw_base_value);\r\n            END IF;\r\n        END IF;\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 3. DATENBANK UPDATES\r\n    -- ==========================================\r\n    UPDATE public.spieler\r\n    SET position = CASE \r\n        WHEN position IS NULL OR position IN ('', 'SUB', 'N/A', 'N/V') THEN v_final_position\r\n        WHEN v_final_position NOT IN ('SUB', 'N/A', 'N/V') AND position NOT LIKE '%' || v_final_position || '%' THEN position || ', ' || v_final_position\r\n        ELSE position\r\n    END\r\n    WHERE id = p_player_id;\r\n\r\n    UPDATE public.spieler_analytics\r\n    SET marktwert = v_calc_mw,\r\n        calculated_marktwert = v_calc_mw,\r\n        last_updated_at = now()\r\n    WHERE spieler_id = p_player_id;\r\n\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "init_player_from_sofascore",
    "args": "p_player_id bigint, p_season_id bigint, p_formation text, p_lineup_index integer, p_api_position text, p_ratings numeric[]",
    "definition": "CREATE OR REPLACE FUNCTION public.init_player_from_sofascore(p_player_id bigint, p_season_id bigint, p_formation text, p_lineup_index integer, p_api_position text, p_ratings numeric[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_final_position text;\r\n    v_avg_points numeric := 0;\r\n    v_calc_mw bigint;\r\n    v_rating numeric;\r\n    v_points_sum numeric := 0;\r\n    v_points_count int := 0;\r\n    v_settings RECORD;\r\nBEGIN\r\n    SELECT * INTO v_settings FROM public.game_settings WHERE id = 1;\r\n    IF v_settings IS NULL THEN v_calc_mw := 1000000; ELSE v_calc_mw := v_settings.mw_base_value; END IF;\r\n\r\n    IF p_formation IS NOT NULL AND p_lineup_index IS NOT NULL AND p_lineup_index <= 10 THEN\r\n        v_final_position := public.get_position_from_formation(p_formation, p_lineup_index);\r\n    END IF;\r\n\r\n    IF v_final_position IS NULL OR v_final_position IN ('N/A', 'SUB', 'N/V') THEN\r\n        v_final_position := CASE \r\n            WHEN p_api_position = 'G' THEN 'TW'\r\n            WHEN p_api_position = 'D' THEN 'IV'\r\n            WHEN p_api_position = 'M' THEN 'ZM'\r\n            WHEN p_api_position = 'F' THEN 'ST'\r\n            ELSE 'SUB'\r\n        END;\r\n    END IF;\r\n\r\n    IF array_length(p_ratings, 1) > 0 THEN\r\n        FOREACH v_rating IN ARRAY p_ratings\r\n        LOOP\r\n            IF v_rating IS NOT NULL THEN\r\n                v_points_sum := v_points_sum + ROUND((v_rating - 6.0) * 100);\r\n                v_points_count := v_points_count + 1;\r\n            END IF;\r\n        END LOOP;\r\n\r\n        IF v_points_count > 0 THEN\r\n            v_avg_points := v_points_sum / v_points_count;\r\n            IF v_avg_points > 0 AND v_settings IS NOT NULL THEN\r\n                v_calc_mw := ROUND(v_settings.mw_multiplier * power(v_avg_points, v_settings.mw_exponent) + v_settings.mw_base_value);\r\n            END IF;\r\n        END IF;\r\n    END IF;\r\n\r\n    UPDATE public.spieler\r\n    SET position = CASE \r\n        WHEN position IS NULL OR position IN ('', 'SUB', 'N/A', 'N/V') THEN v_final_position\r\n        WHEN v_final_position NOT IN ('SUB', 'N/A', 'N/V') AND position NOT LIKE '%' || v_final_position || '%' THEN position || ', ' || v_final_position\r\n        ELSE position\r\n    END\r\n    WHERE id = p_player_id;\r\n\r\n    -- UPSERT IN DIE NEUE TABELLENSTRUKTUR\r\n    INSERT INTO public.spieler_analytics (spieler_id, season_id, marktwert, calculated_marktwert, last_updated_at)\r\n    VALUES (p_player_id, p_season_id, v_calc_mw, v_calc_mw, now())\r\n    ON CONFLICT (spieler_id, season_id) \r\n    DO UPDATE SET \r\n        marktwert = CASE WHEN public.spieler_analytics.marktwert = 1000000 THEN v_calc_mw ELSE public.spieler_analytics.marktwert END,\r\n        calculated_marktwert = v_calc_mw,\r\n        last_updated_at = now();\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "jsonb_add",
    "args": "a jsonb, b jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.jsonb_add(a jsonb, b jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  rec RECORD;\r\n  result JSONB := '{}'::JSONB;\r\nBEGIN\r\n  -- Iteriere über alle Key/Value-Paare in a, aber nur wenn der Wert vom Typ 'number' ist.\r\n  FOR rec IN\r\n    SELECT key, (value::text)::NUMERIC AS num\r\n    FROM jsonb_each(a)\r\n    WHERE jsonb_typeof(value) = 'number'\r\n  LOOP\r\n    result := result || jsonb_build_object(\r\n      rec.key, \r\n      rec.num + COALESCE(\r\n        CASE \r\n          WHEN jsonb_typeof(b->rec.key) = 'number' \r\n          THEN (b->>rec.key)::NUMERIC \r\n          ELSE 0 \r\n        END, \r\n      0)\r\n    );\r\n  END LOOP;\r\n\r\n  -- Füge Keys aus b hinzu, die noch nicht in a vorkamen und deren Wert eine Zahl ist.\r\n  FOR rec IN\r\n    SELECT key, (value::text)::NUMERIC AS num\r\n    FROM jsonb_each(b)\r\n    WHERE jsonb_typeof(value) = 'number'\r\n  LOOP\r\n    IF NOT (result ? rec.key) THEN\r\n      result := result || jsonb_build_object(rec.key, rec.num);\r\n    END IF;\r\n  END LOOP;\r\n\r\n  RETURN result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "jsonb_subtract",
    "args": "a jsonb, b jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.jsonb_subtract(a jsonb, b jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  rec RECORD;\r\n  result JSONB := '{}'::JSONB;\r\nBEGIN\r\n  -- Iteriere über alle Key/Value-Paare in a, aber nur wenn der Wert vom Typ 'number' ist.\r\n  FOR rec IN\r\n    SELECT key, (value::text)::NUMERIC AS num\r\n    FROM jsonb_each(a)\r\n    WHERE jsonb_typeof(value) = 'number'\r\n  LOOP\r\n    result := result || jsonb_build_object(\r\n      rec.key, \r\n      rec.num - COALESCE(\r\n        CASE \r\n          WHEN jsonb_typeof(b->rec.key) = 'number' \r\n          THEN (b->>rec.key)::NUMERIC \r\n          ELSE 0 \r\n        END, \r\n      0)\r\n    );\r\n  END LOOP;\r\n\r\n  RETURN result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "list_player_for_sale",
    "args": "p_league_id bigint, p_player_id bigint, p_buy_now_price integer",
    "definition": "CREATE OR REPLACE FUNCTION public.list_player_for_sale(p_league_id bigint, p_player_id bigint, p_buy_now_price integer)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_marktwert integer;\r\n  v_seller_id uuid;\r\nBEGIN\r\n  v_seller_id := auth.uid();\r\n\r\n  -- HIER GEÄNDERT: Lese aus spieler_analytics statt aus spieler\r\n  SELECT marktwert INTO v_marktwert FROM public.spieler_analytics WHERE spieler_id = p_player_id;\r\n  \r\n  INSERT INTO public.transfer_market (\r\n      league_id, player_id, seller_id, listed_at, expires_at, buy_now_price, min_bid_price, is_active\r\n    )\r\n    VALUES (\r\n      p_league_id, p_player_id, v_seller_id, now(), now() + interval '24 hours',\r\n      p_buy_now_price, v_marktwert, true\r\n    );\r\n\r\n  DELETE FROM public.league_players \r\n  WHERE league_id = p_league_id AND player_id = p_player_id AND user_id = v_seller_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "mark_schedule_updated",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.mark_schedule_updated(p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- 1. Zuerst die Müllabfuhr durchlaufen lassen!\r\n    PERFORM public.cleanup_duplicate_matches(p_season_id);\r\n\r\n    -- 2. Danach den Zeitstempel für das 48-Stunden-Intervall setzen\r\n    UPDATE public.season \r\n    SET last_schedule_update = now() \r\n    WHERE id = p_season_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "on_spieler_created",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.on_spieler_created()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Legt automatisch eine leere Analytics-Zeile mit 1 Mio Startwert an\r\n    INSERT INTO public.spieler_analytics (spieler_id, marktwert, calculated_marktwert)\r\n    VALUES (NEW.id, 1000000, 1000000)\r\n    ON CONFLICT (spieler_id) DO NOTHING;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "process_expired_transfers",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.process_expired_transfers()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  t_rec RECORD;\r\n  bid_rec RECORD;\r\n  v_winner_budget numeric;\r\nBEGIN\r\n  -- Wir gehen alle abgelaufenen, noch aktiven Transfers durch\r\n  FOR t_rec IN\r\n    SELECT * FROM transfer_market\r\n    WHERE is_active = true AND expires_at <= now()\r\n  LOOP\r\n    \r\n    -- 1. Höchstes Gebot suchen\r\n    SELECT * INTO bid_rec\r\n    FROM transfer_bids\r\n    WHERE transfer_id = t_rec.id\r\n    ORDER BY amount DESC\r\n    LIMIT 1;\r\n\r\n    IF bid_rec IS NOT NULL THEN\r\n      ---------------------------------------------------\r\n      -- FALL A: Es gibt einen echten Käufer (Manager)\r\n      ---------------------------------------------------\r\n      \r\n      -- Budget des Käufers prüfen\r\n      SELECT budget INTO v_winner_budget \r\n      FROM league_members \r\n      WHERE league_id = t_rec.league_id AND user_id = bid_rec.bidder_id;\r\n\r\n      IF v_winner_budget >= bid_rec.amount THEN\r\n        -- 1. Geld abziehen (Käufer)\r\n        UPDATE league_members SET budget = budget - bid_rec.amount\r\n        WHERE league_id = t_rec.league_id AND user_id = bid_rec.bidder_id;\r\n\r\n        -- 2. Geld gutschreiben (Verkäufer) - falls es kein System-Verkauf war\r\n        IF t_rec.seller_id IS NOT NULL THEN\r\n          UPDATE league_members SET budget = budget + bid_rec.amount\r\n          WHERE league_id = t_rec.league_id AND user_id = t_rec.seller_id;\r\n        END IF;\r\n\r\n        -- 3. Spieler dem Käufer zuweisen\r\n        -- (Wir erstellen einen NEUEN Eintrag, da der alte beim Anbieten gelöscht wurde)\r\n        INSERT INTO league_players (league_id, user_id, player_id, purchase_price, formation_index)\r\n        VALUES (t_rec.league_id, bid_rec.bidder_id, t_rec.player_id, bid_rec.amount, 99);\r\n\r\n      ELSE\r\n        -- Käufer hat kein Geld mehr -> Transfer platzt\r\n        -- Option: Spieler geht zurück an Verkäufer oder bleibt beim System.\r\n        -- Hier vereinfacht: Wir geben ihn dem Verkäufer zurück.\r\n        IF t_rec.seller_id IS NOT NULL THEN\r\n            INSERT INTO league_players (league_id, user_id, player_id, formation_index)\r\n            VALUES (t_rec.league_id, t_rec.seller_id, t_rec.player_id, 99);\r\n        END IF;\r\n      END IF;\r\n\r\n    ELSE\r\n      ---------------------------------------------------\r\n      -- FALL B: KEIN GEBOT -> SYSTEM KAUFT (Dein neuer Wunsch)\r\n      ---------------------------------------------------\r\n      \r\n      -- Wenn ein Manager der Verkäufer war (nicht das System selbst)\r\n      IF t_rec.seller_id IS NOT NULL THEN\r\n        -- 1. Der Manager bekommt den Marktwert (min_bid_price) vom System\r\n        UPDATE league_members \r\n        SET budget = budget + t_rec.min_bid_price\r\n        WHERE league_id = t_rec.league_id AND user_id = t_rec.seller_id;\r\n        \r\n        -- 2. Spieler-Besitz:\r\n        -- Der Spieler wurde beim Anbieten ja schon gelöscht.\r\n        -- Wir müssen NICHTS tun. Er ist nun \"vereinslos\" in dieser Liga \r\n        -- und wird automatisch vom nächsten System-Transfer-Zyklus \r\n        -- wieder in den Topf geworfen (da er in 'league_players' nicht existiert).\r\n      END IF;\r\n\r\n    END IF;\r\n\r\n    -- Transfer abschließen\r\n    UPDATE transfer_market SET is_active = false WHERE id = t_rec.id;\r\n\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "process_match_lineups",
    "args": "p_spiel_id bigint, p_season_id bigint, p_raw_json jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.process_match_lineups(p_spiel_id bigint, p_season_id bigint, p_raw_json jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_home_formation text;\r\n    v_away_formation text;\r\n    v_home_id int;\r\n    v_away_id int;\r\n    v_team_type text;\r\n    v_team_id int;\r\n    v_formation text;\r\n    v_idx int;\r\n    player_item jsonb;\r\n    v_player_id int;\r\n    v_player_name text;\r\n    v_api_pos text;\r\n    v_calc_pos text;\r\n    v_rating numeric;\r\n    v_stats jsonb;\r\n    v_fantasy_points int;\r\n    v_match_rating_id bigint;\r\nBEGIN\r\n    -- 1. DEBUGGING: Wir speichern das JSON, um zu sehen, was ankommt!\r\n    INSERT INTO public.api_debug_dump (spiel_id, raw_json)\r\n    VALUES (p_spiel_id, p_raw_json);\r\n\r\n    -- IDs holen\r\n    SELECT heimteam_id, auswärtsteam_id INTO v_home_id, v_away_id\r\n    FROM spiel WHERE id = p_spiel_id;\r\n\r\n    v_home_formation := p_raw_json->'home'->>'formation';\r\n    v_away_formation := p_raw_json->'away'->>'formation';\r\n\r\n    -- Formationen speichern (mit Array-Fix)\r\n    IF v_home_formation IS NOT NULL AND v_home_formation <> 'N/A' THEN\r\n        INSERT INTO formation (formation, positionsliste) \r\n        VALUES (v_home_formation, public.calculate_formation_array(v_home_formation)) \r\n        ON CONFLICT DO NOTHING;\r\n    END IF;\r\n    \r\n    IF v_away_formation IS NOT NULL AND v_away_formation <> 'N/A' THEN\r\n        INSERT INTO formation (formation, positionsliste) \r\n        VALUES (v_away_formation, public.calculate_formation_array(v_away_formation)) \r\n        ON CONFLICT DO NOTHING;\r\n    END IF;\r\n\r\n    UPDATE spiel \r\n    SET hometeam_formation = v_home_formation,\r\n        awayteam_formation = v_away_formation,\r\n        last_updated_at = now() \r\n    WHERE id = p_spiel_id;\r\n\r\n    -- Die Hauptschleife\r\n    FOREACH v_team_type IN ARRAY ARRAY['home', 'away'] LOOP\r\n        IF v_team_type = 'home' THEN\r\n            v_team_id := v_home_id;\r\n            v_formation := v_home_formation;\r\n        ELSE\r\n            v_team_id := v_away_id;\r\n            v_formation := v_away_formation;\r\n        END IF;\r\n\r\n        v_idx := 0;\r\n        \r\n        -- WICHTIG: Hier prüfen wir, ob 'players' existiert. Wenn nicht, passiert gar nichts.\r\n        FOR player_item IN SELECT * FROM jsonb_array_elements(p_raw_json->v_team_type->'players')\r\n        LOOP\r\n            v_player_id := (player_item->'player'->>'id')::int;\r\n            v_player_name := player_item->'player'->>'name';\r\n            v_api_pos := player_item->'player'->>'position';\r\n            v_stats := player_item->'statistics';\r\n            v_rating := (v_stats->>'rating')::numeric;\r\n\r\n            v_calc_pos := public.get_position_from_formation(v_formation, v_idx);\r\n            \r\n            -- Fallback Position, falls Formation unklar\r\n            IF v_calc_pos = 'N/A' OR v_calc_pos IS NULL THEN\r\n                 v_calc_pos := CASE \r\n                    WHEN v_api_pos = 'G' THEN 'TW'\r\n                    WHEN v_api_pos = 'D' THEN 'IV'\r\n                    WHEN v_api_pos = 'M' THEN 'ZM'\r\n                    WHEN v_api_pos = 'F' THEN 'ST'\r\n                    ELSE 'SUB'\r\n                 END;\r\n            END IF;\r\n\r\n            v_fantasy_points := public.calculate_fantasy_points(v_api_pos, v_stats);\r\n\r\n            -- =========================================================\r\n            -- HIER IST DIE NEUE LOGIK FÜR DAS HINZUFÜGEN DER POSITIONEN\r\n            -- =========================================================\r\n            INSERT INTO spieler (id, name, position, team_id)\r\n            VALUES (v_player_id, v_player_name, v_calc_pos, v_team_id)\r\n            ON CONFLICT (id) DO UPDATE \r\n            SET \r\n                team_id = EXCLUDED.team_id,\r\n                position = CASE \r\n                    -- 1. Uninteressante neue Position ('SUB', 'N/A', 'N/V') -> behalte die alte \r\n                    -- (falls die alte NULL ist, nimm trotzdem die neue, damit wenigstens 'SUB' drinsteht)\r\n                    WHEN EXCLUDED.position IN ('SUB', 'N/A', 'N/V') THEN \r\n                        COALESCE(spieler.position, EXCLUDED.position)\r\n                        \r\n                    -- 2. Alte Position ist nutzlos ('SUB', 'N/A', 'N/V', NULL oder Leer) -> komplett überschreiben\r\n                    WHEN spieler.position IS NULL OR spieler.position IN ('', 'SUB', 'N/A', 'N/V') THEN \r\n                        EXCLUDED.position\r\n                        \r\n                    -- 3. Die neue Position ist bereits in der Liste -> nichts verändern\r\n                    WHEN EXCLUDED.position = ANY(string_to_array(replace(spieler.position, ' ', ''), ',')) THEN\r\n                        spieler.position\r\n                        \r\n                    -- 4. Neue, gültige Position, die noch fehlt -> Kommagetrennt anhängen (z.B. \"ZM, ZOM\")\r\n                    ELSE \r\n                        spieler.position || ', ' || EXCLUDED.position\r\n                END;\r\n\r\n            INSERT INTO season_players (season_id, player_id, team_id)\r\n            VALUES (p_season_id, v_player_id, v_team_id)\r\n            ON CONFLICT (season_id, player_id) DO NOTHING;\r\n\r\n            v_match_rating_id := (p_spiel_id::text || v_player_id::text)::bigint;\r\n\r\n            -- Text-Cast Fix für match_position\r\n            INSERT INTO matchrating (id, spiel_id, spieler_id, punkte, statistics, neuepunkte, formationsindex, match_position)\r\n            VALUES (v_match_rating_id, p_spiel_id, v_player_id, ROUND((COALESCE(v_rating, 6.0) - 6) * 100), v_stats, v_fantasy_points, v_idx, v_calc_pos)\r\n            ON CONFLICT (id) DO UPDATE\r\n            SET punkte = EXCLUDED.punkte, statistics = EXCLUDED.statistics, neuepunkte = EXCLUDED.neuepunkte, formationsindex = EXCLUDED.formationsindex, match_position = EXCLUDED.match_position;\r\n\r\n            v_idx := v_idx + 1;\r\n        END LOOP;\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "process_random_system_transfers",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.process_random_system_transfers()\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_league RECORD;\r\n    v_user_count INT;\r\n    v_market_size INT;\r\n    v_target_size INT;\r\n    v_probability NUMERIC;\r\n    v_random NUMERIC;\r\nBEGIN\r\n    -- 1. Schleife: Gehe durch alle AKTIVEN Ligen\r\n    FOR v_league IN \r\n        SELECT id, season_id FROM public.leagues WHERE is_active = true AND season_id IS NOT NULL\r\n    LOOP\r\n        -- 2. Wie viele Nutzer (Manager) spielen in dieser Liga mit?\r\n        SELECT COUNT(*) INTO v_user_count \r\n        FROM public.league_members \r\n        WHERE league_id = v_league.id;\r\n\r\n        -- 3. Wie viele System-Spieler sind aktuell auf dem Markt?\r\n        -- (seller_id IS NULL bedeutet, der Spieler kommt vom System)\r\n        SELECT COUNT(*) INTO v_market_size \r\n        FROM public.transfer_market \r\n        WHERE league_id = v_league.id AND is_active = true AND seller_id IS NULL;\r\n\r\n        -- 4. Berechne die Ziel-Größe des Transfermarkts (BALANCING)\r\n        -- Hier eingestellt: 4 Spieler pro User, mindestens aber 10 Spieler insgesamt.\r\n        v_target_size := GREATEST(10, v_user_count * 4);\r\n\r\n        -- 5. Berechne die Wahrscheinlichkeit\r\n        IF v_market_size >= v_target_size THEN\r\n            -- Der Markt ist schon gut gefüllt. Nur 5% Chance auf einen neuen Spieler.\r\n            v_probability := 0.05; \r\n        ELSE\r\n            -- Wahrscheinlichkeit basierend auf der Lücke (Je leerer, desto höher die Chance)\r\n            v_probability := (v_target_size - v_market_size)::NUMERIC / v_target_size::NUMERIC;\r\n        END IF;\r\n\r\n        -- 6. Würfeln! (Zufallszahl zwischen 0.00 und 1.00 generieren)\r\n        v_random := random();\r\n\r\n        -- 7. Gewonnen? Dann stelle 1 Spieler auf den Markt!\r\n        IF v_random <= v_probability THEN\r\n            -- Wir nutzen deine bereits vorhandene Funktion, um 1 Spieler hinzuzufügen\r\n            PERFORM public.generate_daily_transfers(v_league.id, v_league.season_id, 1);\r\n        END IF;\r\n\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "quick_sell_player",
    "args": "p_league_id bigint, p_player_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.quick_sell_player(p_league_id bigint, p_player_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_mw integer;\r\n  v_sell_price integer;\r\n  v_user_id uuid;\r\nBEGIN\r\n  v_user_id := auth.uid();\r\n\r\n  IF NOT EXISTS (SELECT 1 FROM public.league_players WHERE league_id = p_league_id AND player_id = p_player_id AND user_id = v_user_id) THEN\r\n    RAISE EXCEPTION 'Spieler gehört dir nicht oder ist bereits auf dem Transfermarkt.';\r\n  END IF;\r\n\r\n  -- HIER GEÄNDERT: Lese aus spieler_analytics statt aus spieler\r\n  SELECT marktwert INTO v_mw FROM public.spieler_analytics WHERE spieler_id = p_player_id;\r\n  \r\n  v_sell_price := floor(v_mw * 0.95);\r\n\r\n  UPDATE public.league_members \r\n  SET budget = budget + v_sell_price \r\n  WHERE league_id = p_league_id AND user_id = v_user_id;\r\n\r\n  DELETE FROM public.league_players \r\n  WHERE league_id = p_league_id AND player_id = p_player_id AND user_id = v_user_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "request_sync_permission",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.request_sync_permission()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_last_sync timestamptz;\r\n    v_timeout timestamptz;\r\n    v_current_user uuid;\r\nBEGIN\r\n    v_current_user := auth.uid();\r\n\r\n    -- Aktuellen Status holen\r\n    SELECT last_sync_at, lock_timeout\r\n    INTO v_last_sync, v_timeout\r\n    FROM public.api_sync_lock\r\n    WHERE id = 1;\r\n\r\n    -- REGEL 1: Ist der letzte Sync weniger als 5 Minuten her? -> BLOCKIEREN\r\n    IF v_last_sync > (now() - interval '5 minutes') THEN\r\n        RETURN false;\r\n    END IF;\r\n\r\n    -- REGEL 2: Ist gerade gesperrt und Timeout noch nicht abgelaufen? -> BLOCKIEREN\r\n    IF v_timeout > now() THEN\r\n        RETURN false;\r\n    END IF;\r\n\r\n    -- GRÜNES LICHT: Wir setzen den Lock für diesen User für 2 Minuten\r\n    UPDATE public.api_sync_lock\r\n    SET is_locked_by = v_current_user,\r\n        last_sync_at = now(), -- Wir setzen den Zeitstempel jetzt auf Start\r\n        lock_timeout = now() + interval '2 minutes' -- Sicherheitsnetz falls App abstürzt\r\n    WHERE id = 1;\r\n\r\n    RETURN true;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "save_lineup",
    "args": "p_league_id bigint, p_updates jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.save_lineup(p_league_id bigint, p_updates jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  item JSONB;\r\nBEGIN\r\n  -- Wir iterieren durch das JSON-Array, das vom Frontend kommt\r\n  FOR item IN SELECT * FROM jsonb_array_elements(p_updates) \r\n  LOOP\r\n    UPDATE league_players\r\n    SET formation_index = (item->>'index')::int\r\n    WHERE league_id = p_league_id\r\n      AND user_id = auth.uid() -- Sicherheitscheck: Nur eigene Spieler bearbeiten\r\n      AND player_id = (item->>'player_id')::int;\r\n  END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "transform_statistics",
    "args": "input jsonb",
    "definition": "CREATE OR REPLACE FUNCTION public.transform_statistics(input jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  mp NUMERIC;\r\n  rec RECORD;\r\n  result JSONB := '{}'::JSONB;\r\nBEGIN\r\n  -- Versuche, den Wert für minutesPlayed auszulesen\r\n  mp := (input->>'minutesPlayed')::NUMERIC;\r\n  \r\n  FOR rec IN SELECT key, value FROM jsonb_each(input)\r\n  LOOP\r\n    IF rec.key IN ('rating', 'minutesPlayed') THEN\r\n      -- Diese Keys werden unverändert übernommen\r\n      result := result || jsonb_build_object(rec.key, rec.value);\r\n    ELSIF jsonb_typeof(rec.value) = 'number' THEN\r\n      IF mp IS NOT NULL AND mp >= 1 THEN\r\n        -- Transformation: (Wert / minutesPlayed) * 90\r\n        result := result || jsonb_build_object(rec.key, ((rec.value::text)::NUMERIC / mp) * 90);\r\n      ELSE\r\n        result := result || jsonb_build_object(rec.key, rec.value);\r\n      END IF;\r\n    ELSE\r\n      -- Falls der Wert kein reiner numerischer Wert ist (z.B. ein verschachteltes Objekt),\r\n      -- wird er unverändert übernommen.\r\n      result := result || jsonb_build_object(rec.key, rec.value);\r\n    END IF;\r\n  END LOOP;\r\n  RETURN result;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_fill_market_on_reactivation",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_fill_market_on_reactivation()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Wir prüfen: War die Liga vorher inaktiv (false) und ist JETZT aktiv (true)?\r\n    IF OLD.is_active = false AND NEW.is_active = true AND NEW.season_id IS NOT NULL THEN\r\n        -- Wenn ja: Werfe als \"Willkommens-Boost\" 10 frische Spieler auf den Markt\r\n        PERFORM public.generate_daily_transfers(NEW.id, NEW.season_id, 10);\r\n    END IF;\r\n\r\n    -- WICHTIG: Einen Trigger muss man immer mit RETURN NEW beenden\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "trigger_update_team_analytics_on_final",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_team_analytics_on_final()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    -- Wir feuern die Berechnung nur ab, wenn der Status von etwas anderem auf 'final' wechselt\r\n    IF NEW.status = 'final' AND OLD.status IS DISTINCT FROM 'final' THEN\r\n        -- Beide Teams des Spiels berechnen\r\n        PERFORM public.update_team_analytics(NEW.heimteam_id, NEW.season_id);\r\n        PERFORM public.update_team_analytics(NEW.auswärtsteam_id, NEW.season_id);\r\n    END IF;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_all_matchup_faktors",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.update_all_matchup_faktors(p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_team RECORD;\r\nBEGIN\r\n    -- Geht alle Teams dieser Saison durch und berechnet den Faktor neu\r\n    FOR v_team IN \r\n        SELECT DISTINCT team_id \r\n        FROM public.season_teams \r\n        WHERE season_id = p_season_id\r\n    LOOP\r\n        PERFORM public.update_matchup_faktor(v_team.team_id, p_season_id);\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_all_spieler_analytics",
    "args": "p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.update_all_spieler_analytics(p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_player RECORD;\r\nBEGIN\r\n    -- Geht alle aktiven Spieler dieser Saison durch\r\n    FOR v_player IN \r\n        SELECT player_id \r\n        FROM public.season_players \r\n        WHERE season_id = p_season_id\r\n    LOOP\r\n        PERFORM public.update_spieler_analytics_prognose(v_player.player_id, p_season_id);\r\n    END LOOP;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_gesamtstatistiken",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.update_gesamtstatistiken()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\ndeclare\r\n  v_mr_id bigint;\r\n  player_id bigint;\r\n  _season_id bigint;\r\n  _stats_sum jsonb := '{}'::jsonb;\r\n  aggregated_stats jsonb;\r\n  total_punkte numeric := 0;\r\n  total_matches bigint := 0;\r\nbegin\r\n  v_mr_id := coalesce(\r\n    (case when new is not null then (new.id)::bigint end),\r\n    (case when old is not null then (old.id)::bigint end)\r\n  );\r\n\r\n  if v_mr_id is null then return null; end if;\r\n\r\n  select mr.spieler_id::bigint, sp.season_id::bigint\r\n  into player_id, _season_id\r\n  from matchrating mr\r\n  join spiel sp on sp.id = mr.spiel_id\r\n  where mr.id = v_mr_id\r\n  limit 1;\r\n\r\n  if player_id is null or _season_id is null then return null; end if;\r\n\r\n  select coalesce(jsonb_object_agg(key, val_sum), '{}'::jsonb)\r\n  into _stats_sum\r\n  from (\r\n    select e.key,\r\n      sum(\r\n        case jsonb_typeof(e.val)\r\n          when 'number' then (e.val)::text::numeric\r\n          when 'object' then coalesce(\r\n            nullif(regexp_replace(e.val->>'original','[^0-9\\.-]+','','g'),'')::numeric,\r\n            nullif(regexp_replace(e.val->>'alternative','[^0-9\\.-]+','','g'),'')::numeric,\r\n            nullif(regexp_replace(e.val->>'value','[^0-9\\.-]+','','g'),'')::numeric,\r\n            0\r\n          )\r\n          when 'string' then coalesce(nullif(regexp_replace(e.val::text,'[^0-9\\.-]+','','g'), '')::numeric, 0)\r\n          else 0\r\n        end\r\n      ) as val_sum\r\n    from matchrating mr\r\n    join spiel sp on sp.id = mr.spiel_id\r\n    cross join lateral jsonb_each(coalesce(mr.statistics, '{}'::jsonb)) as e(key, val)\r\n    where mr.spieler_id = player_id and sp.season_id = _season_id\r\n    group by e.key\r\n  ) sub;\r\n\r\n  select coalesce(sum(mr.punkte)::numeric, 0), coalesce(count(*)::bigint, 0)\r\n  into total_punkte, total_matches\r\n  from matchrating mr\r\n  join spiel sp on sp.id = mr.spiel_id\r\n  where mr.spieler_id = player_id and sp.season_id = _season_id;\r\n\r\n  -- HIER DIE VEREINFACHUNG: Wir überschreiben einfach das flache JSON!\r\n  if total_matches = 0 then\r\n    update public.spieler_analytics\r\n    set gesamtstatistiken = '{}'::jsonb, anzahl_spiele = 0\r\n    where spieler_id = player_id and season_id = _season_id;\r\n    return null;\r\n  end if;\r\n\r\n  aggregated_stats := coalesce(_stats_sum, '{}'::jsonb)\r\n    || jsonb_build_object('gesamtpunkte', total_punkte);\r\n\r\n  -- UPSERT für die Analytics (Falls es die Zeile noch nicht gibt)\r\n  INSERT INTO public.spieler_analytics (spieler_id, season_id, gesamtstatistiken, anzahl_spiele)\r\n  VALUES (player_id, _season_id, aggregated_stats, total_matches)\r\n  ON CONFLICT (spieler_id, season_id) \r\n  DO UPDATE SET \r\n    gesamtstatistiken = aggregated_stats,\r\n    anzahl_spiele = total_matches;\r\n\r\n  return null;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_matchup_faktor",
    "args": "p_team_id bigint, p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.update_matchup_faktor(p_team_id bigint, p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_own_strength numeric;\r\n    v_opp_strength numeric;\r\n    v_matchup_val numeric;\r\n    v_total_factor numeric := 0;\r\n    v_game_count int := 0;\r\n    v_weights numeric[] := ARRAY[0.50, 0.35, 0.15];\r\n    v_weight_sum numeric := 0;\r\n    v_game RECORD;\r\nBEGIN\r\n    -- 1. Eigene Stärke holen\r\n    SELECT gesamtstaerke INTO v_own_strength FROM public.team_analytics WHERE team_id = p_team_id;\r\n    IF v_own_strength IS NULL THEN v_own_strength := 5.0; END IF;\r\n\r\n    -- 2. Nächste 3 anstehende Spiele des Teams holen\r\n    FOR v_game IN \r\n        SELECT heimteam_id, auswärtsteam_id \r\n        FROM public.spiel \r\n        WHERE season_id = p_season_id \r\n          AND status = 'nicht gestartet'\r\n          AND (heimteam_id = p_team_id OR auswärtsteam_id = p_team_id)\r\n        ORDER BY datum ASC\r\n        LIMIT 3\r\n    LOOP\r\n        v_game_count := v_game_count + 1;\r\n        \r\n        -- Gegner identifizieren und dessen Stärke holen\r\n        IF v_game.heimteam_id = p_team_id THEN\r\n            SELECT gesamtstaerke INTO v_opp_strength FROM public.team_analytics WHERE team_id = v_game.auswärtsteam_id;\r\n        ELSE\r\n            SELECT gesamtstaerke INTO v_opp_strength FROM public.team_analytics WHERE team_id = v_game.heimteam_id;\r\n        END IF;\r\n        \r\n        -- Falls der Gegner noch keine Stärke hat, nehmen wir den Durchschnitt (5.0)\r\n        IF v_opp_strength IS NULL OR v_opp_strength = 0 THEN v_opp_strength := 5.0; END IF;\r\n        \r\n        -- Einzelnen Matchup-Faktor berechnen (Eigene Stärke / Gegner Stärke)\r\n        v_matchup_val := v_own_strength / v_opp_strength;\r\n        \r\n        -- Dämpfen: Der Faktor darf minimal 0.5 (Halbe Punkte) und maximal 1.5 (+50% Punkte) sein\r\n        v_matchup_val := GREATEST(0.5, LEAST(1.5, v_matchup_val));\r\n        \r\n        -- Mit Gewichtung (50%, 35%, 15%) multiplizieren und aufaddieren\r\n        v_total_factor := v_total_factor + (v_matchup_val * v_weights[v_game_count]);\r\n        v_weight_sum := v_weight_sum + v_weights[v_game_count];\r\n    END LOOP;\r\n\r\n    -- 3. Fallback: Falls weniger als 3 Spiele gefunden wurden (Saisonende)\r\n    IF v_weight_sum < 1.0 THEN\r\n        v_total_factor := v_total_factor + ((1.0 - v_weight_sum) * 1.0);\r\n    END IF;\r\n    \r\n    IF v_game_count = 0 THEN\r\n        v_total_factor := 1.0;\r\n    END IF;\r\n\r\n    -- 4. In die Datenbank schreiben\r\n    UPDATE public.team_analytics\r\n    SET matchup_faktor = ROUND(v_total_factor, 2)\r\n    WHERE team_id = p_team_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_spieler_analytics_prognose",
    "args": "p_spieler_id bigint, p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.update_spieler_analytics_prognose(p_spieler_id bigint, p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_team_id bigint;\r\n    v_matchup_faktor numeric;\r\n    \r\n    v_punkteschnitt numeric := 0;\r\n    v_form numeric := 0;\r\n    v_startelf_quote numeric := 0;\r\n    v_expected_points numeric := 0;\r\nBEGIN\r\n    -- 1. Team des Spielers herausfinden\r\n    SELECT team_id INTO v_team_id \r\n    FROM public.season_players \r\n    WHERE player_id = p_spieler_id AND season_id = p_season_id \r\n    LIMIT 1;\r\n\r\n    -- Falls der Spieler in dieser Saison (noch) keinem Team zugewiesen ist, abbrechen\r\n    IF v_team_id IS NULL THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- 2. Matchup-Faktor des Teams laden (Standard: 1.0)\r\n    SELECT COALESCE(matchup_faktor, 1.0) INTO v_matchup_faktor \r\n    FROM public.team_analytics \r\n    WHERE team_id = v_team_id;\r\n\r\n    -- 3. Saison-Punkteschnitt des Spielers berechnen\r\n    SELECT COALESCE(AVG(punkte), 0) INTO v_punkteschnitt\r\n    FROM public.matchrating mr\r\n    JOIN public.spiel s ON mr.spiel_id = s.id\r\n    WHERE mr.spieler_id = p_spieler_id AND s.season_id = p_season_id;\r\n\r\n    -- 4. Form und Startelf-Quote aus den LETZTEN 5 TEAM-SPIELEN berechnen\r\n    -- Wir holen die letzten 5 Spiele des TEAMS und schauen, was der Spieler da gemacht hat.\r\n    SELECT \r\n        -- Form: Durchschnitt der Punkte in den Spielen, in denen er EINGESETZT wurde\r\n        COALESCE(AVG(mr.punkte), 0),\r\n        -- Quote: Wie oft stand er in der Startelf (Index <= 10) geteilt durch die Anzahl der Team-Spiele (max 5)\r\n        COALESCE(COUNT(mr.id) FILTER (WHERE mr.formationsindex <= 10)::numeric / GREATEST(COUNT(last_games.id), 1), 0)\r\n    INTO v_form, v_startelf_quote\r\n    FROM (\r\n        SELECT id \r\n        FROM public.spiel \r\n        WHERE season_id = p_season_id \r\n          AND status = 'final'\r\n          AND (heimteam_id = v_team_id OR auswärtsteam_id = v_team_id)\r\n        ORDER BY datum DESC\r\n        LIMIT 5\r\n    ) as last_games\r\n    -- LEFT JOIN: Wenn mr.id NULL ist, hat der Spieler in diesem Spiel nicht gespielt\r\n    LEFT JOIN public.matchrating mr ON mr.spiel_id = last_games.id AND mr.spieler_id = p_spieler_id;\r\n\r\n    -- 5. Expected Points berechnen\r\n    -- Formel: (40% Saison + 60% Form) * Matchup * Startelf-Wahrscheinlichkeit\r\n    v_expected_points := ((v_punkteschnitt * 0.4) + (v_form * 0.6)) * v_matchup_faktor * v_startelf_quote;\r\n\r\n    -- Expected Points kappen wir auf minimal 0 (Ein Spieler soll keinen krassen negativen Marktwert-Zielwert bekommen)\r\n    v_expected_points := GREATEST(0, ROUND(v_expected_points, 2));\r\n\r\n    -- 6. Daten in spieler_analytics speichern\r\n    UPDATE public.spieler_analytics\r\n    SET punkteschnitt = ROUND(v_punkteschnitt, 2),\r\n        form = ROUND(v_form, 2),\r\n        startelf_quote = ROUND(v_startelf_quote, 2),\r\n        expected_points = v_expected_points,\r\n        last_updated_at = now()\r\n    WHERE spieler_id = p_spieler_id;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_spieler_stats_on_delete",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.update_spieler_stats_on_delete()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  UPDATE public.spieler_analytics\r\n  SET \r\n    gesamtstatistiken = jsonb_subtract(gesamtstatistiken, OLD.statistics),\r\n    anzahl_spiele = GREATEST(COALESCE(anzahl_spiele, 0) - 1, 0)\r\n  WHERE spieler_id = OLD.spieler_id; -- HIER GEÄNDERT auf spieler_analytics\r\n  \r\n  RETURN OLD;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_spieler_stats_on_insert",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.update_spieler_stats_on_insert()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  UPDATE public.spieler_analytics\r\n  SET \r\n    gesamtstatistiken = jsonb_add(COALESCE(gesamtstatistiken, '{}'::jsonb), NEW.statistics),\r\n    anzahl_spiele = COALESCE(anzahl_spiele, 0) + 1\r\n  WHERE spieler_id = NEW.spieler_id; -- HIER GEÄNDERT auf spieler_analytics\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_spieler_stats_on_update",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.update_spieler_stats_on_update()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  delta JSONB;\r\nBEGIN\r\n  delta := jsonb_subtract(NEW.statistics, OLD.statistics);\r\n  \r\n  UPDATE public.spieler_analytics\r\n  SET gesamtstatistiken = jsonb_add(gesamtstatistiken, delta)\r\n  WHERE spieler_id = NEW.spieler_id; -- HIER GEÄNDERT auf spieler_analytics\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_spieltag_status",
    "args": "",
    "definition": "CREATE OR REPLACE FUNCTION public.update_spieltag_status()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_total integer;\r\n    v_final integer;\r\n    v_nicht_gestartet integer;\r\n    v_new_status text;\r\nBEGIN\r\n    -- 1. Wir zählen die Status aller Spiele für diesen spezifischen Spieltag\r\n    -- HIER KORRIGIERT: \"round = NEW.round\"\r\n    SELECT \r\n        COUNT(*),\r\n        COUNT(*) FILTER (WHERE status = 'final'),\r\n        COUNT(*) FILTER (WHERE status = 'nicht gestartet' OR status = 'verschoben' OR status = 'canceled')\r\n    INTO \r\n        v_total, \r\n        v_final, \r\n        v_nicht_gestartet\r\n    FROM public.spiel\r\n    WHERE round = NEW.round AND season_id = NEW.season_id;\r\n\r\n    -- 2. Sicherheitssperre, falls keine Spiele gefunden wurden\r\n    IF v_total = 0 THEN\r\n        RETURN NEW;\r\n    END IF;\r\n\r\n    -- 3. Deine Logik-Regeln anwenden\r\n    IF v_final = v_total THEN\r\n        v_new_status := 'final';\r\n    ELSIF v_nicht_gestartet = v_total THEN\r\n        v_new_status := 'nicht gestartet';\r\n    ELSE\r\n        v_new_status := 'läuft';\r\n    END IF;\r\n\r\n    -- 4. Den Status in der Spieltag-Tabelle aktualisieren\r\n    -- HIER KORRIGIERT: \"round = NEW.round\"\r\n    UPDATE public.spieltag\r\n    SET status = v_new_status\r\n    WHERE round = NEW.round AND season_id = NEW.season_id;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_team_analytics",
    "args": "p_team_id bigint, p_season_id bigint",
    "definition": "CREATE OR REPLACE FUNCTION public.update_team_analytics(p_team_id bigint, p_season_id bigint)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_matches RECORD;\r\n    v_points int := 0;\r\n    v_goals_for int := 0;\r\n    v_goals_against int := 0;\r\n    v_match_count int := 0;\r\n    \r\n    v_form_points int := 0;\r\n    v_form_match_count int := 0;\r\n    \r\n    v_score_home int;\r\n    v_score_away int;\r\n    v_is_home boolean;\r\n    \r\n    v_calc_strength numeric;\r\n    v_calc_form numeric;\r\nBEGIN\r\n    -- Hole alle beendeten Spiele des Teams in dieser Saison, absteigend sortiert (neueste zuerst)\r\n    FOR v_matches IN \r\n        SELECT heimteam_id, auswärtsteam_id, ergebnis \r\n        FROM public.spiel \r\n        WHERE season_id = p_season_id \r\n          AND status = 'final'\r\n          AND (heimteam_id = p_team_id OR auswärtsteam_id = p_team_id)\r\n        ORDER BY datum DESC\r\n    LOOP\r\n        -- Ergebnis parsen (Format z.B. \"2:1\")\r\n        BEGIN\r\n            v_score_home := split_part(v_matches.ergebnis, ':', 1)::int;\r\n            v_score_away := split_part(v_matches.ergebnis, ':', 2)::int;\r\n        EXCEPTION WHEN OTHERS THEN\r\n            -- Falls Ergebnis z.B. \"Noch kein Ergebnis\" ist oder einen Fehler wirft, überspringen wir das Spiel\r\n            CONTINUE; \r\n        END;\r\n\r\n        v_is_home := (v_matches.heimteam_id = p_team_id);\r\n        v_match_count := v_match_count + 1;\r\n        \r\n        -- Tore zuweisen\r\n        IF v_is_home THEN\r\n            v_goals_for := v_goals_for + v_score_home;\r\n            v_goals_against := v_goals_against + v_score_away;\r\n        ELSE\r\n            v_goals_for := v_goals_for + v_score_away;\r\n            v_goals_against := v_goals_against + v_score_home;\r\n        END IF;\r\n\r\n        -- Punkte berechnen (3 für Sieg, 1 für Remis)\r\n        IF (v_is_home AND v_score_home > v_score_away) OR (NOT v_is_home AND v_score_away > v_score_home) THEN\r\n            v_points := v_points + 3;\r\n            IF v_match_count <= 5 THEN v_form_points := v_form_points + 3; END IF;\r\n        ELSIF v_score_home = v_score_away THEN\r\n            v_points := v_points + 1;\r\n            IF v_match_count <= 5 THEN v_form_points := v_form_points + 1; END IF;\r\n        END IF;\r\n\r\n        -- Zähler für die letzten 5 Spiele (Form)\r\n        IF v_match_count <= 5 THEN\r\n            v_form_match_count := v_form_match_count + 1;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    -- ==========================================\r\n    -- 2. MATHEMATISCHE AUSWERTUNG\r\n    -- ==========================================\r\n\r\n    -- FORM berechnen (0.00 bis 3.00)\r\n    IF v_form_match_count > 0 THEN\r\n        v_calc_form := ROUND((v_form_points::numeric / v_form_match_count::numeric), 2);\r\n    ELSE\r\n        v_calc_form := 0.00;\r\n    END IF;\r\n\r\n    -- STÄRKE berechnen (Skala 1.00 bis 10.00)\r\n    IF v_match_count > 0 THEN\r\n        -- Basisstärke durch Punkte (max 7.5) + Tordifferenz-Bonus (Tordifferenz pro Spiel * 0.5)\r\n        v_calc_strength := (v_points::numeric / v_match_count::numeric) * 2.5 + \r\n                           ((v_goals_for - v_goals_against)::numeric / v_match_count::numeric) * 0.5 + 2.5;\r\n        \r\n        -- Sicherstellen, dass der Wert das Limit (1 bis 10) nicht sprengt\r\n        v_calc_strength := LEAST(GREATEST(v_calc_strength, 1.0), 10.0);\r\n        v_calc_strength := ROUND(v_calc_strength, 2);\r\n    ELSE\r\n        v_calc_strength := 5.00; -- Standardwert für Teams ohne Spiele\r\n    END IF;\r\n\r\n    -- ==========================================\r\n    -- 3. IN DATENBANK SPEICHERN\r\n    -- ==========================================\r\n    UPDATE public.team_analytics\r\n    SET gesamtstaerke = v_calc_strength,\r\n        form = v_calc_form,\r\n        last_updated_at = now()\r\n    WHERE team_id = p_team_id;\r\n\r\nEND;\r\n$function$\n"
  }
]